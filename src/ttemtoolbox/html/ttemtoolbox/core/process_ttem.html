<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ttemtoolbox.core.process_ttem API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ttemtoolbox.core.process_ttem</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# process_ttem.py
# Version 11.18.2023
# Created: 2023-11-17
# Author: Jiawei Li
import pathlib
from pathlib import Path
import re
import pandas as pd
import geopandas as gpd
import numpy as np
from ttemtoolbox.defaults.constants import XYZ_FILE_PATTERN, DOI_FILE_PATTERN
from ttemtoolbox.utils.tools import skip_metadata


class ProcessTTEM:
    &#34;&#34;&#34;
    This function is used to format the tTEM data, and return a dataframe that contains filtered/processed tTEM data.\n
    if the input is a string or pathlib.PurePath object, the function will read the tTEM data from the file and \
    return a dataframe.\n
    if the input is a dataframe, the function will reuse the dataframe and return a dataframe.\n
    if the input is a list, the function will read all the tTEM data from the files in the list and return a \
    dataframe.\n
    Version 11.18.2023 \n
    :param fname: A string or pathlib.PurePath object that contains the path to the tTEM .xyz file exported from Aarhus Workbench
    :param doi_path: A string or pathlib.PurePath object that contains the path to the DOI file exported from Aarhus Workbench
    :param layer_exclude: A list that contains the layer number that you want to exclude from the tTEM data
    :param line_exclude: A list that contains the line number that you want to exclude from the tTEM data
    :param point_exclude: A list that contains the point number that you want to exclude from the tTEM data
    :param resample: A int value that indicates whether to fill the tTEM data with a factor, defaults is False
    :return: A pandas dataframe that contains the filtered/processed tTEM data
    &#34;&#34;&#34;
    def __init__(self,
                 fname: pathlib.PurePath |str |list,
                 doi_path: pathlib.PurePath| str| list = None,
                 layer_exclude: list = None,
                 line_exclude: list = None,
                 ID_exclude: list = None,
                 resample: int = None,
                 unit: str = &#39;meter&#39;):
        if not isinstance(fname, list):
            fname = [fname]
        if not isinstance(doi_path, list) and doi_path:
            doi_path = [doi_path]
        if unit == &#39;meter&#39;:
            self.unit = &#39;meter&#39;
            self.unitconvert = 1
        elif unit == &#39;feet&#39;:
            self.unit = &#39;feet&#39;
            self.unitconvert = 3.28084
        self.fname = fname
        self.doi_path = doi_path
        self.layer_exclude = layer_exclude
        self.line_exclude = line_exclude
        self.ID_exclude = ID_exclude
        self.resample = resample
        self.data = self._format_ttem()
        self.crs = self.data.crs

    @staticmethod
    def _read_ttem(fname: pathlib.PurePath| str, mtoft=1) -&gt; pd.DataFrame| dict:
        &#34;&#34;&#34;
        This function read tTEM data from .xyz file, and return a formatted dataframe that contains all the tTEM data. \n
        Version 11.18.2023 \n
        :param fname: A string or pathlib.PurePath object that contains the path to the tTEM .xyz file exported from Aarhus Workbench
        :return: A pandas dataframe that contains all the tTEM data without any filtering
        &#34;&#34;&#34;
        data = skip_metadata(fname, XYZ_FILE_PATTERN)
        df = pd.DataFrame(data[1::], columns=data[0])
        df = df.astype({&#39;ID&#39;: &#39;int64&#39;,
                                &#39;Line_No&#39;: &#39;int64&#39;,
                                &#39;Layer_No&#39;: &#39;int64&#39;,
                                &#39;UTMX&#39;: &#39;float64&#39;,
                                &#39;UTMY&#39;: &#39;float64&#39;,
                                &#39;Elevation_Cell&#39;: &#39;float64&#39;,
                                &#39;Resistivity&#39;: &#39;float64&#39;,
                                &#39;Resistivity_STD&#39;: &#39;float64&#39;,
                                &#39;Conductivity&#39;: &#39;float64&#39;,
                                &#39;Depth_top&#39;: &#39;float64&#39;,
                                &#39;Depth_bottom&#39;: &#39;float64&#39;,
                                &#39;Thickness&#39;: &#39;float64&#39;,
                                &#39;Thickness_STD&#39;: &#39;float64&#39;
                                })
        df = df[~(df[&#39;Thickness_STD&#39;] == float(9999))]
        df[&#39;Elevation_Cell&#39;] = df[&#39;Elevation_Cell&#39;]/mtoft
        df[&#39;Depth_top&#39;] = df[&#39;Depth_top&#39;]/mtoft
        df[&#39;Depth_bottom&#39;] = df[&#39;Depth_bottom&#39;]/mtoft
        df[&#39;Thickness&#39;] = df[&#39;Thickness&#39;]/mtoft
        return df
    
    @staticmethod
    def _find_crs(fname: pathlib.PurePath| str) -&gt; str:
        &#34;&#34;&#34;
        This function is used to find the CRS of the tTEM data, it will return the CRS of the tTEM data. \n
         \n
        :param fname: A string or pathlib.PurePath object that contains the path to the tTEM .xyz file exported from Aarhus Workbench
        :return: CRS of the tTEM data
        &#34;&#34;&#34;
        with open(fname, &#34;r&#34;) as file:
            lines = file.readlines()
        pattern = re.compile(r&#34;epsg:(\d+)&#34;, re.IGNORECASE)
        for line in lines:
            match = pattern.search(line)
            if match:
                crs = match.group()
                crs = crs.upper()
                break
            else:
                crs = None
        return crs


    @staticmethod
    def _DOI(dataframe: pd.DataFrame,
             doi_path: pathlib.PurePath| str |list,
             mtoft=1) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Remove all tTEM data under DOI elevation limit with provided DOI file from Aarhus Workbench \n
        Version 11.18.2023 \n
        :param dataframe: Datafram that constains tTEM data
        :param doi_path: path-like contains DOI file, or a list of path that contains multiple DOI files
        :return: Filtered tTEM data above DOI
        &#34;&#34;&#34;
        
        doi_concatlist = []
        match_index = []
        for i in doi_path:
            print(&#39;Applying DOI {}.....&#39;.format(Path(i).name))
            data = skip_metadata(i, DOI_FILE_PATTERN)
            tmp_doi_df = pd.DataFrame(data[1::], columns=data[0])
            doi_concatlist.append(tmp_doi_df)
        df_DOI = pd.concat(doi_concatlist)
        df_DOI = df_DOI.astype({&#39;UTMX&#39;: &#39;float64&#39;,
                                &#39;UTMY&#39;: &#39;float64&#39;,
                                &#39;Value&#39;: &#39;float64&#39;
                                })
        df_DOI[&#39;Value&#39;] = df_DOI[&#39;Value&#39;]/mtoft
        df_group = dataframe.groupby([&#39;UTMX&#39;, &#39;UTMY&#39;])
        ttem_concatlist = []
        for name, group in df_group:
            try:
                elevation = df_DOI.loc[(df_DOI[&#39;UTMX&#39;] == name[0]) &amp; (df_DOI[&#39;UTMY&#39;] == name[1])][&#39;Value&#39;].values[0]
                new_group = group[group[&#39;Elevation_Cell&#39;] &gt;= elevation]
                
                ttem_concatlist.append(new_group)
            except IndexError:
                continue
        df_out = pd.concat(ttem_concatlist)
        return df_out

    @staticmethod
    def _layer_exclude(dataframe: pd.DataFrame,
                       layer_exclude: list) -&gt; pd.DataFrame:
        df_out = dataframe[~np.isin(dataframe[&#34;Layer_No&#34;], layer_exclude)]
        print(&#39;Exclude layer {}&#39;.format(layer_exclude))
        return df_out

    @staticmethod
    def _line_exclude(dataframe: pd.DataFrame,
                      line_exclude: list) -&gt; pd.DataFrame:
        df_out = dataframe[~np.isin(dataframe[&#34;Line_No&#34;], line_exclude)]
        print(&#39;Exclude line {}&#39;.format(line_exclude))
        return df_out

    @staticmethod
    def _ID_exclude(dataframe: pd.DataFrame,
                       ID_exclude: list) -&gt; pd.DataFrame:
        df_out = dataframe[~dataframe[&#34;ID&#34;].isin(ID_exclude)]
        [print(&#39;Exclude point {}&#39;.format(x)) for x in ID_exclude]
        return df_out

    @staticmethod
    def _to_linear(group: pd.DataFrame,
                   factor: int) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        The core algorithm of the resample method, it fills the tTEM from log to linear.\n
        Version 11.18.2023\n
        :param group: tTEM dataframe, typically a groups from pd.groupby method
        :param factor: how thin your thickness should be divided, e.g. 10 means 1/10 m thickness
        :return: linear thickness tTEM dataframe
        &#34;&#34;&#34;

        newgroup = group.loc[group.index.repeat(group.Thickness * factor)]
        mul_per_gr = newgroup.groupby(&#39;Elevation_Cell&#39;).cumcount()
        newgroup[&#39;Elevation_Cell&#39;] = newgroup[&#39;Elevation_Cell&#39;].subtract(mul_per_gr * 1 / factor)
        newgroup[&#39;Depth_top&#39;] = newgroup[&#39;Depth_top&#39;].add(mul_per_gr * 1 / factor)
        newgroup[&#39;Depth_bottom&#39;] = newgroup[&#39;Depth_top&#39;].add(1 / factor)
        newgroup[&#39;Elevation_End&#39;] = newgroup[&#39;Elevation_Cell&#39;].subtract(1 / factor)
        newgroup[&#39;Thickness&#39;] = 1 / factor
        return newgroup

    @staticmethod
    def _resample(dataframe: pd.DataFrame,
                  factor: int) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        This staticmethod is connected with format_ttem method, it converts the tTEM thickness from log to linear \
        layers with a consistant layer thickness .\n
        Version 11.18.2023\n
        :param dataframe: Dataframe that contains the tTEM data
        :param factor: how thin your thickness should be divided, e.g. 10 means 1/10 m thickness
        :return: resampled dataframe
        &#34;&#34;&#34;
        concatlist = []
        groups = dataframe.groupby([&#39;UTMX&#39;, &#39;UTMY&#39;])
        for name, group in groups:
            newgroup = ProcessTTEM._to_linear(group, factor)
            concatlist.append(newgroup)
        result = pd.concat(concatlist)
        result.reset_index(drop=True, inplace=True)
        return result
    
    @staticmethod
    def _get_crs(fname: str | pathlib.PurePath) -&gt; str:
        try:
            crs = ProcessTTEM._find_crs(fname[0])
        except:
            print(&#39;No CRS found in the file, set CRS to None, use set_crs method to assign a CRS.&#39;)
            crs = None
        return crs

    def _format_ttem(self):
        &#34;&#34;&#34;
        This is the core method of the class that read file under varies input circumstances, and return a \
        formatted dataframe that contains filtered tTEM data. \n
        Version: 11.18.2023\n
        :return: A pandas dataframe that contains filtered tTEM data
        &#34;&#34;&#34;
    # Read data under different input circumstances
        from pathlib import Path
        crs = self._get_crs(self.fname)
        tmp_df = pd.DataFrame()
        if len(self.fname) == 0:
            raise ValueError(&#34;The input is empty!&#34;)
        if isinstance(self.fname[0], (str, pathlib.PurePath)):
            concatlist = []
            for i in self.fname:
                tmp_df = self._read_ttem(i, self.unitconvert)
                concatlist.append(tmp_df)
                print(&#34;Reading data from file {}...&#34;.format(Path(i).name))
            tmp_df = pd.concat(concatlist)
        elif isinstance(self.fname[0], pd.DataFrame):
            print(&#34;Reading data from cache...&#34;)
            tmp_df = pd.concat(self.fname)
        if tmp_df.empty:
            raise ValueError(&#34;The input is empty!&#34;)
    # Create filter parameters
        if self.layer_exclude is not None:
            tmp_df = self._layer_exclude(tmp_df, self.layer_exclude)
        if self.line_exclude is not None:
            tmp_df = self._layer_exclude(tmp_df, self.line_exclude)
        if self.ID_exclude is not None:
            tmp_df = self._ID_exclude(tmp_df, self.ID_exclude)
        if self.doi_path is not None:
            tmp_df = self._DOI(tmp_df, self.doi_path)
        if self.resample is not None:
            tmp_df = self._resample(tmp_df, self.resample)
    # Sort the dataframe
        tmp_df = tmp_df.sort_values(by=[&#39;ID&#39;, &#39;Line_No&#39;,&#39;Layer_No&#39;])
        tmp_df.reset_index(drop=True, inplace=True)
        tmp_df[&#34;Elevation_End&#34;] = tmp_df[&#34;Elevation_Cell&#34;].subtract(tmp_df[&#34;Thickness&#34;])
        self.data = tmp_df.copy()
        self.data.rename(columns={&#39;UTMX&#39;: &#39;X&#39;, &#39;UTMY&#39;: &#39;Y&#39;},inplace=True)
        if crs is not None:
            self.data = gpd.GeoDataFrame(self.data, 
                                        geometry=gpd.points_from_xy(self.data[&#39;X&#39;], self.data[&#39;Y&#39;]),
                                        crs=crs)
        else: 
            self.data = gpd.GeoDataFrame(self.data, 
                                        geometry=gpd.points_from_xy(self.data[&#39;X&#39;], self.data[&#39;Y&#39;]))
        return self.data

    

    def summary(self) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;
        This function generate a summary of the tTEM file which can be plot in the GIS contains all key information \
        about the tTEM
        :return: pd.DataFrame containing the summary of the tTEM info
        &#34;&#34;&#34;

        id_group = self.data.groupby(&#39;ID&#39;)
        agg_group = id_group.agg({&#39;Depth_bottom&#39;: &#39;max&#39;,
                                  &#39;Elevation_Cell&#39;: &#39;max&#39;,
                                  &#39;Elevation_End&#39;: &#39;min&#39;,
                                  &#39;Resistivity&#39;: [&#39;min&#39;, &#39;max&#39;, &#39;mean&#39;],
                                  &#39;X&#39;: &#39;mean&#39;, &#39;Y&#39;: &#39;mean&#39;})
        agg_group.columns = agg_group.columns.map(&#39;_&#39;.join)
        agg_group.index.name = None
        agg_group[&#39;ID&#39;] = agg_group.index
        self.summary = agg_group
        self.summary.reset_index(drop=True, inplace=True)
        self.summary.rename(columns={&#39;X_mean&#39;: &#39;X&#39;, &#39;Y_mean&#39;: &#39;Y&#39;}, inplace=True)
        return self.summary
    
    def set_crs(self, new_crs: str):
        &#34;&#34;&#34;
        Assigns a new coordinate reference system (CRS) to the object.

        Parameters:
            new_crs (str): The new CRS to be assigned. It should be in the format &#39;EPSG:&lt;code&gt;&#39;,
                           where &lt;code&gt; is the EPSG code of the CRS.

        Returns:
            str: The newly assigned CRS.

        Raises:
            ValueError: If the input CRS is not in the correct format.

        Example:
            &gt;&gt;&gt; obj = ProcessTTEM(fname)
            &gt;&gt;&gt; obj.assign_crs(&#39;EPSG:4326&#39;)
            The CRS is assigned to EPSG:4326
            &#39;EPSG:4326&#39;
        &#34;&#34;&#34;
        pattern = r&#39;^EPSG:\d+$&#39;
        if bool(re.match(pattern, new_crs)):
            self.data.set_crs(new_crs, inplace=True)
            print(&#39;The CRS is assigned to {}&#39;.format(new_crs))
        else: 
            raise ValueError(&#34;The input CRS is not valid, please use EPSG format, e.g. EPSG:4326&#34;)
        return self.crs
    
    def reproject(self, new_crs: str):
        &#34;&#34;&#34;
        Reprojects the data to a new coordinate reference system (CRS).

        Parameters:
            new_crs (str): The new CRS to reproject the data to.

        Returns:
            GeoDataFrame: The reprojected data as a GeoDataFrame.
        &#34;&#34;&#34;
        
        self.data = self.data.to_crs(new_crs)
        self.crs = self.data.crs
        self.data[&#39;X&#39;] = self.data.geometry.x
        self.data[&#39;Y&#39;] = self.data.geometry.y
        return self.data
        
        
    def to_shp(self, output_filepath: str | pathlib.PurePath):
        &#34;&#34;&#34;
        This method converts the tTEM data to a shapefile or other supported geospatial formats.\n
        :param output_filepath: The path to save the output shapefile or geospatial file.
        
        &#34;&#34;&#34;
        ttem_gdf = gpd.GeoDataFrame(self.summary, 
                                    geometry=gpd.points_from_xy(self.summary[&#39;X&#39;], self.summary[&#39;Y&#39;]),
                                    crs=self.crs)
        if  Path(output_filepath).suffix.lower() == &#39;.shp&#39;:
            ttem_gdf.to_file(output_filepath, driver=&#39;ESRI Shapefile&#39;)
            print(&#39;The output file is saved to {}&#39;.format(Path(output_filepath).resolve()))
        elif Path(output_filepath).suffix.lower() == &#39;.gpkg&#39;:
            ttem_gdf.to_file(output_filepath, driver=&#39;GPKG&#39;, layer=Path(self.fname[0]).stem)
            print(&#39;The output file is saved to {}&#39;.format(Path(output_filepath).resolve()))
        elif Path(output_filepath).suffix.lower() == &#39;.geojson&#39;:
            ttem_gdf.to_file(output_filepath, driver=&#39;GeoJSON&#39;)
            print(&#39;The output file is saved to {}&#39;.format(Path(output_filepath).resolve()))
        else: 
            raise ValueError(&#34;The output file format is not supported, please use .shp, .gpkg, or .geojson&#34;)
            


if __name__ == &#34;__main__&#34;:
    print(&#39;This is a module, please import it to use it.&#39;)
    import ttemtoolbox
    from pathlib import Path
    import geopandas as gpd
    from pathlib import Path
    workdir = Path.cwd()
    ttem_lslake = workdir.parent.parent.joinpath(r&#39;data\PD22_I03_MOD.xyz&#39;)
    ttem_lsl = ttemtoolbox.process_ttem.ProcessTTEM(ttem_lslake)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ttemtoolbox.core.process_ttem.ProcessTTEM"><code class="flex name class">
<span>class <span class="ident">ProcessTTEM</span></span>
<span>(</span><span>fname: pathlib.PurePath | str | list, doi_path: pathlib.PurePath | str | list = None, layer_exclude: list = None, line_exclude: list = None, ID_exclude: list = None, resample: int = None, unit: str = 'meter')</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to format the tTEM data, and return a dataframe that contains filtered/processed tTEM data.</p>
<p>if the input is a string or pathlib.PurePath object, the function will read the tTEM data from the file and
return a dataframe.</p>
<p>if the input is a dataframe, the function will reuse the dataframe and return a dataframe.</p>
<p>if the input is a list, the function will read all the tTEM data from the files in the list and return a
dataframe.</p>
<p>Version 11.18.2023 </p>
<p>:param fname: A string or pathlib.PurePath object that contains the path to the tTEM .xyz file exported from Aarhus Workbench
:param doi_path: A string or pathlib.PurePath object that contains the path to the DOI file exported from Aarhus Workbench
:param layer_exclude: A list that contains the layer number that you want to exclude from the tTEM data
:param line_exclude: A list that contains the line number that you want to exclude from the tTEM data
:param point_exclude: A list that contains the point number that you want to exclude from the tTEM data
:param resample: A int value that indicates whether to fill the tTEM data with a factor, defaults is False
:return: A pandas dataframe that contains the filtered/processed tTEM data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessTTEM:
    &#34;&#34;&#34;
    This function is used to format the tTEM data, and return a dataframe that contains filtered/processed tTEM data.\n
    if the input is a string or pathlib.PurePath object, the function will read the tTEM data from the file and \
    return a dataframe.\n
    if the input is a dataframe, the function will reuse the dataframe and return a dataframe.\n
    if the input is a list, the function will read all the tTEM data from the files in the list and return a \
    dataframe.\n
    Version 11.18.2023 \n
    :param fname: A string or pathlib.PurePath object that contains the path to the tTEM .xyz file exported from Aarhus Workbench
    :param doi_path: A string or pathlib.PurePath object that contains the path to the DOI file exported from Aarhus Workbench
    :param layer_exclude: A list that contains the layer number that you want to exclude from the tTEM data
    :param line_exclude: A list that contains the line number that you want to exclude from the tTEM data
    :param point_exclude: A list that contains the point number that you want to exclude from the tTEM data
    :param resample: A int value that indicates whether to fill the tTEM data with a factor, defaults is False
    :return: A pandas dataframe that contains the filtered/processed tTEM data
    &#34;&#34;&#34;
    def __init__(self,
                 fname: pathlib.PurePath |str |list,
                 doi_path: pathlib.PurePath| str| list = None,
                 layer_exclude: list = None,
                 line_exclude: list = None,
                 ID_exclude: list = None,
                 resample: int = None,
                 unit: str = &#39;meter&#39;):
        if not isinstance(fname, list):
            fname = [fname]
        if not isinstance(doi_path, list) and doi_path:
            doi_path = [doi_path]
        if unit == &#39;meter&#39;:
            self.unit = &#39;meter&#39;
            self.unitconvert = 1
        elif unit == &#39;feet&#39;:
            self.unit = &#39;feet&#39;
            self.unitconvert = 3.28084
        self.fname = fname
        self.doi_path = doi_path
        self.layer_exclude = layer_exclude
        self.line_exclude = line_exclude
        self.ID_exclude = ID_exclude
        self.resample = resample
        self.data = self._format_ttem()
        self.crs = self.data.crs

    @staticmethod
    def _read_ttem(fname: pathlib.PurePath| str, mtoft=1) -&gt; pd.DataFrame| dict:
        &#34;&#34;&#34;
        This function read tTEM data from .xyz file, and return a formatted dataframe that contains all the tTEM data. \n
        Version 11.18.2023 \n
        :param fname: A string or pathlib.PurePath object that contains the path to the tTEM .xyz file exported from Aarhus Workbench
        :return: A pandas dataframe that contains all the tTEM data without any filtering
        &#34;&#34;&#34;
        data = skip_metadata(fname, XYZ_FILE_PATTERN)
        df = pd.DataFrame(data[1::], columns=data[0])
        df = df.astype({&#39;ID&#39;: &#39;int64&#39;,
                                &#39;Line_No&#39;: &#39;int64&#39;,
                                &#39;Layer_No&#39;: &#39;int64&#39;,
                                &#39;UTMX&#39;: &#39;float64&#39;,
                                &#39;UTMY&#39;: &#39;float64&#39;,
                                &#39;Elevation_Cell&#39;: &#39;float64&#39;,
                                &#39;Resistivity&#39;: &#39;float64&#39;,
                                &#39;Resistivity_STD&#39;: &#39;float64&#39;,
                                &#39;Conductivity&#39;: &#39;float64&#39;,
                                &#39;Depth_top&#39;: &#39;float64&#39;,
                                &#39;Depth_bottom&#39;: &#39;float64&#39;,
                                &#39;Thickness&#39;: &#39;float64&#39;,
                                &#39;Thickness_STD&#39;: &#39;float64&#39;
                                })
        df = df[~(df[&#39;Thickness_STD&#39;] == float(9999))]
        df[&#39;Elevation_Cell&#39;] = df[&#39;Elevation_Cell&#39;]/mtoft
        df[&#39;Depth_top&#39;] = df[&#39;Depth_top&#39;]/mtoft
        df[&#39;Depth_bottom&#39;] = df[&#39;Depth_bottom&#39;]/mtoft
        df[&#39;Thickness&#39;] = df[&#39;Thickness&#39;]/mtoft
        return df
    
    @staticmethod
    def _find_crs(fname: pathlib.PurePath| str) -&gt; str:
        &#34;&#34;&#34;
        This function is used to find the CRS of the tTEM data, it will return the CRS of the tTEM data. \n
         \n
        :param fname: A string or pathlib.PurePath object that contains the path to the tTEM .xyz file exported from Aarhus Workbench
        :return: CRS of the tTEM data
        &#34;&#34;&#34;
        with open(fname, &#34;r&#34;) as file:
            lines = file.readlines()
        pattern = re.compile(r&#34;epsg:(\d+)&#34;, re.IGNORECASE)
        for line in lines:
            match = pattern.search(line)
            if match:
                crs = match.group()
                crs = crs.upper()
                break
            else:
                crs = None
        return crs


    @staticmethod
    def _DOI(dataframe: pd.DataFrame,
             doi_path: pathlib.PurePath| str |list,
             mtoft=1) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Remove all tTEM data under DOI elevation limit with provided DOI file from Aarhus Workbench \n
        Version 11.18.2023 \n
        :param dataframe: Datafram that constains tTEM data
        :param doi_path: path-like contains DOI file, or a list of path that contains multiple DOI files
        :return: Filtered tTEM data above DOI
        &#34;&#34;&#34;
        
        doi_concatlist = []
        match_index = []
        for i in doi_path:
            print(&#39;Applying DOI {}.....&#39;.format(Path(i).name))
            data = skip_metadata(i, DOI_FILE_PATTERN)
            tmp_doi_df = pd.DataFrame(data[1::], columns=data[0])
            doi_concatlist.append(tmp_doi_df)
        df_DOI = pd.concat(doi_concatlist)
        df_DOI = df_DOI.astype({&#39;UTMX&#39;: &#39;float64&#39;,
                                &#39;UTMY&#39;: &#39;float64&#39;,
                                &#39;Value&#39;: &#39;float64&#39;
                                })
        df_DOI[&#39;Value&#39;] = df_DOI[&#39;Value&#39;]/mtoft
        df_group = dataframe.groupby([&#39;UTMX&#39;, &#39;UTMY&#39;])
        ttem_concatlist = []
        for name, group in df_group:
            try:
                elevation = df_DOI.loc[(df_DOI[&#39;UTMX&#39;] == name[0]) &amp; (df_DOI[&#39;UTMY&#39;] == name[1])][&#39;Value&#39;].values[0]
                new_group = group[group[&#39;Elevation_Cell&#39;] &gt;= elevation]
                
                ttem_concatlist.append(new_group)
            except IndexError:
                continue
        df_out = pd.concat(ttem_concatlist)
        return df_out

    @staticmethod
    def _layer_exclude(dataframe: pd.DataFrame,
                       layer_exclude: list) -&gt; pd.DataFrame:
        df_out = dataframe[~np.isin(dataframe[&#34;Layer_No&#34;], layer_exclude)]
        print(&#39;Exclude layer {}&#39;.format(layer_exclude))
        return df_out

    @staticmethod
    def _line_exclude(dataframe: pd.DataFrame,
                      line_exclude: list) -&gt; pd.DataFrame:
        df_out = dataframe[~np.isin(dataframe[&#34;Line_No&#34;], line_exclude)]
        print(&#39;Exclude line {}&#39;.format(line_exclude))
        return df_out

    @staticmethod
    def _ID_exclude(dataframe: pd.DataFrame,
                       ID_exclude: list) -&gt; pd.DataFrame:
        df_out = dataframe[~dataframe[&#34;ID&#34;].isin(ID_exclude)]
        [print(&#39;Exclude point {}&#39;.format(x)) for x in ID_exclude]
        return df_out

    @staticmethod
    def _to_linear(group: pd.DataFrame,
                   factor: int) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        The core algorithm of the resample method, it fills the tTEM from log to linear.\n
        Version 11.18.2023\n
        :param group: tTEM dataframe, typically a groups from pd.groupby method
        :param factor: how thin your thickness should be divided, e.g. 10 means 1/10 m thickness
        :return: linear thickness tTEM dataframe
        &#34;&#34;&#34;

        newgroup = group.loc[group.index.repeat(group.Thickness * factor)]
        mul_per_gr = newgroup.groupby(&#39;Elevation_Cell&#39;).cumcount()
        newgroup[&#39;Elevation_Cell&#39;] = newgroup[&#39;Elevation_Cell&#39;].subtract(mul_per_gr * 1 / factor)
        newgroup[&#39;Depth_top&#39;] = newgroup[&#39;Depth_top&#39;].add(mul_per_gr * 1 / factor)
        newgroup[&#39;Depth_bottom&#39;] = newgroup[&#39;Depth_top&#39;].add(1 / factor)
        newgroup[&#39;Elevation_End&#39;] = newgroup[&#39;Elevation_Cell&#39;].subtract(1 / factor)
        newgroup[&#39;Thickness&#39;] = 1 / factor
        return newgroup

    @staticmethod
    def _resample(dataframe: pd.DataFrame,
                  factor: int) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        This staticmethod is connected with format_ttem method, it converts the tTEM thickness from log to linear \
        layers with a consistant layer thickness .\n
        Version 11.18.2023\n
        :param dataframe: Dataframe that contains the tTEM data
        :param factor: how thin your thickness should be divided, e.g. 10 means 1/10 m thickness
        :return: resampled dataframe
        &#34;&#34;&#34;
        concatlist = []
        groups = dataframe.groupby([&#39;UTMX&#39;, &#39;UTMY&#39;])
        for name, group in groups:
            newgroup = ProcessTTEM._to_linear(group, factor)
            concatlist.append(newgroup)
        result = pd.concat(concatlist)
        result.reset_index(drop=True, inplace=True)
        return result
    
    @staticmethod
    def _get_crs(fname: str | pathlib.PurePath) -&gt; str:
        try:
            crs = ProcessTTEM._find_crs(fname[0])
        except:
            print(&#39;No CRS found in the file, set CRS to None, use set_crs method to assign a CRS.&#39;)
            crs = None
        return crs

    def _format_ttem(self):
        &#34;&#34;&#34;
        This is the core method of the class that read file under varies input circumstances, and return a \
        formatted dataframe that contains filtered tTEM data. \n
        Version: 11.18.2023\n
        :return: A pandas dataframe that contains filtered tTEM data
        &#34;&#34;&#34;
    # Read data under different input circumstances
        from pathlib import Path
        crs = self._get_crs(self.fname)
        tmp_df = pd.DataFrame()
        if len(self.fname) == 0:
            raise ValueError(&#34;The input is empty!&#34;)
        if isinstance(self.fname[0], (str, pathlib.PurePath)):
            concatlist = []
            for i in self.fname:
                tmp_df = self._read_ttem(i, self.unitconvert)
                concatlist.append(tmp_df)
                print(&#34;Reading data from file {}...&#34;.format(Path(i).name))
            tmp_df = pd.concat(concatlist)
        elif isinstance(self.fname[0], pd.DataFrame):
            print(&#34;Reading data from cache...&#34;)
            tmp_df = pd.concat(self.fname)
        if tmp_df.empty:
            raise ValueError(&#34;The input is empty!&#34;)
    # Create filter parameters
        if self.layer_exclude is not None:
            tmp_df = self._layer_exclude(tmp_df, self.layer_exclude)
        if self.line_exclude is not None:
            tmp_df = self._layer_exclude(tmp_df, self.line_exclude)
        if self.ID_exclude is not None:
            tmp_df = self._ID_exclude(tmp_df, self.ID_exclude)
        if self.doi_path is not None:
            tmp_df = self._DOI(tmp_df, self.doi_path)
        if self.resample is not None:
            tmp_df = self._resample(tmp_df, self.resample)
    # Sort the dataframe
        tmp_df = tmp_df.sort_values(by=[&#39;ID&#39;, &#39;Line_No&#39;,&#39;Layer_No&#39;])
        tmp_df.reset_index(drop=True, inplace=True)
        tmp_df[&#34;Elevation_End&#34;] = tmp_df[&#34;Elevation_Cell&#34;].subtract(tmp_df[&#34;Thickness&#34;])
        self.data = tmp_df.copy()
        self.data.rename(columns={&#39;UTMX&#39;: &#39;X&#39;, &#39;UTMY&#39;: &#39;Y&#39;},inplace=True)
        if crs is not None:
            self.data = gpd.GeoDataFrame(self.data, 
                                        geometry=gpd.points_from_xy(self.data[&#39;X&#39;], self.data[&#39;Y&#39;]),
                                        crs=crs)
        else: 
            self.data = gpd.GeoDataFrame(self.data, 
                                        geometry=gpd.points_from_xy(self.data[&#39;X&#39;], self.data[&#39;Y&#39;]))
        return self.data

    

    def summary(self) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;
        This function generate a summary of the tTEM file which can be plot in the GIS contains all key information \
        about the tTEM
        :return: pd.DataFrame containing the summary of the tTEM info
        &#34;&#34;&#34;

        id_group = self.data.groupby(&#39;ID&#39;)
        agg_group = id_group.agg({&#39;Depth_bottom&#39;: &#39;max&#39;,
                                  &#39;Elevation_Cell&#39;: &#39;max&#39;,
                                  &#39;Elevation_End&#39;: &#39;min&#39;,
                                  &#39;Resistivity&#39;: [&#39;min&#39;, &#39;max&#39;, &#39;mean&#39;],
                                  &#39;X&#39;: &#39;mean&#39;, &#39;Y&#39;: &#39;mean&#39;})
        agg_group.columns = agg_group.columns.map(&#39;_&#39;.join)
        agg_group.index.name = None
        agg_group[&#39;ID&#39;] = agg_group.index
        self.summary = agg_group
        self.summary.reset_index(drop=True, inplace=True)
        self.summary.rename(columns={&#39;X_mean&#39;: &#39;X&#39;, &#39;Y_mean&#39;: &#39;Y&#39;}, inplace=True)
        return self.summary
    
    def set_crs(self, new_crs: str):
        &#34;&#34;&#34;
        Assigns a new coordinate reference system (CRS) to the object.

        Parameters:
            new_crs (str): The new CRS to be assigned. It should be in the format &#39;EPSG:&lt;code&gt;&#39;,
                           where &lt;code&gt; is the EPSG code of the CRS.

        Returns:
            str: The newly assigned CRS.

        Raises:
            ValueError: If the input CRS is not in the correct format.

        Example:
            &gt;&gt;&gt; obj = ProcessTTEM(fname)
            &gt;&gt;&gt; obj.assign_crs(&#39;EPSG:4326&#39;)
            The CRS is assigned to EPSG:4326
            &#39;EPSG:4326&#39;
        &#34;&#34;&#34;
        pattern = r&#39;^EPSG:\d+$&#39;
        if bool(re.match(pattern, new_crs)):
            self.data.set_crs(new_crs, inplace=True)
            print(&#39;The CRS is assigned to {}&#39;.format(new_crs))
        else: 
            raise ValueError(&#34;The input CRS is not valid, please use EPSG format, e.g. EPSG:4326&#34;)
        return self.crs
    
    def reproject(self, new_crs: str):
        &#34;&#34;&#34;
        Reprojects the data to a new coordinate reference system (CRS).

        Parameters:
            new_crs (str): The new CRS to reproject the data to.

        Returns:
            GeoDataFrame: The reprojected data as a GeoDataFrame.
        &#34;&#34;&#34;
        
        self.data = self.data.to_crs(new_crs)
        self.crs = self.data.crs
        self.data[&#39;X&#39;] = self.data.geometry.x
        self.data[&#39;Y&#39;] = self.data.geometry.y
        return self.data
        
        
    def to_shp(self, output_filepath: str | pathlib.PurePath):
        &#34;&#34;&#34;
        This method converts the tTEM data to a shapefile or other supported geospatial formats.\n
        :param output_filepath: The path to save the output shapefile or geospatial file.
        
        &#34;&#34;&#34;
        ttem_gdf = gpd.GeoDataFrame(self.summary, 
                                    geometry=gpd.points_from_xy(self.summary[&#39;X&#39;], self.summary[&#39;Y&#39;]),
                                    crs=self.crs)
        if  Path(output_filepath).suffix.lower() == &#39;.shp&#39;:
            ttem_gdf.to_file(output_filepath, driver=&#39;ESRI Shapefile&#39;)
            print(&#39;The output file is saved to {}&#39;.format(Path(output_filepath).resolve()))
        elif Path(output_filepath).suffix.lower() == &#39;.gpkg&#39;:
            ttem_gdf.to_file(output_filepath, driver=&#39;GPKG&#39;, layer=Path(self.fname[0]).stem)
            print(&#39;The output file is saved to {}&#39;.format(Path(output_filepath).resolve()))
        elif Path(output_filepath).suffix.lower() == &#39;.geojson&#39;:
            ttem_gdf.to_file(output_filepath, driver=&#39;GeoJSON&#39;)
            print(&#39;The output file is saved to {}&#39;.format(Path(output_filepath).resolve()))
        else: 
            raise ValueError(&#34;The output file format is not supported, please use .shp, .gpkg, or .geojson&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ttemtoolbox.core.process_ttem.ProcessTTEM.reproject"><code class="name flex">
<span>def <span class="ident">reproject</span></span>(<span>self, new_crs: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Reprojects the data to a new coordinate reference system (CRS).</p>
<h2 id="parameters">Parameters</h2>
<p>new_crs (str): The new CRS to reproject the data to.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>GeoDataFrame</code></dt>
<dd>The reprojected data as a GeoDataFrame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reproject(self, new_crs: str):
    &#34;&#34;&#34;
    Reprojects the data to a new coordinate reference system (CRS).

    Parameters:
        new_crs (str): The new CRS to reproject the data to.

    Returns:
        GeoDataFrame: The reprojected data as a GeoDataFrame.
    &#34;&#34;&#34;
    
    self.data = self.data.to_crs(new_crs)
    self.crs = self.data.crs
    self.data[&#39;X&#39;] = self.data.geometry.x
    self.data[&#39;Y&#39;] = self.data.geometry.y
    return self.data</code></pre>
</details>
</dd>
<dt id="ttemtoolbox.core.process_ttem.ProcessTTEM.set_crs"><code class="name flex">
<span>def <span class="ident">set_crs</span></span>(<span>self, new_crs: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Assigns a new coordinate reference system (CRS) to the object.</p>
<h2 id="parameters">Parameters</h2>
<p>new_crs (str): The new CRS to be assigned. It should be in the format 'EPSG:<code>',
where <code> is the EPSG code of the CRS.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The newly assigned CRS.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the input CRS is not in the correct format.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; obj = ProcessTTEM(fname)
&gt;&gt;&gt; obj.assign_crs('EPSG:4326')
The CRS is assigned to EPSG:4326
'EPSG:4326'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_crs(self, new_crs: str):
    &#34;&#34;&#34;
    Assigns a new coordinate reference system (CRS) to the object.

    Parameters:
        new_crs (str): The new CRS to be assigned. It should be in the format &#39;EPSG:&lt;code&gt;&#39;,
                       where &lt;code&gt; is the EPSG code of the CRS.

    Returns:
        str: The newly assigned CRS.

    Raises:
        ValueError: If the input CRS is not in the correct format.

    Example:
        &gt;&gt;&gt; obj = ProcessTTEM(fname)
        &gt;&gt;&gt; obj.assign_crs(&#39;EPSG:4326&#39;)
        The CRS is assigned to EPSG:4326
        &#39;EPSG:4326&#39;
    &#34;&#34;&#34;
    pattern = r&#39;^EPSG:\d+$&#39;
    if bool(re.match(pattern, new_crs)):
        self.data.set_crs(new_crs, inplace=True)
        print(&#39;The CRS is assigned to {}&#39;.format(new_crs))
    else: 
        raise ValueError(&#34;The input CRS is not valid, please use EPSG format, e.g. EPSG:4326&#34;)
    return self.crs</code></pre>
</details>
</dd>
<dt id="ttemtoolbox.core.process_ttem.ProcessTTEM.summary"><code class="name flex">
<span>def <span class="ident">summary</span></span>(<span>self) ‑> geopandas.geodataframe.GeoDataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>This function generate a summary of the tTEM file which can be plot in the GIS contains all key information
about the tTEM
:return: pd.DataFrame containing the summary of the tTEM info</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summary(self) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    This function generate a summary of the tTEM file which can be plot in the GIS contains all key information \
    about the tTEM
    :return: pd.DataFrame containing the summary of the tTEM info
    &#34;&#34;&#34;

    id_group = self.data.groupby(&#39;ID&#39;)
    agg_group = id_group.agg({&#39;Depth_bottom&#39;: &#39;max&#39;,
                              &#39;Elevation_Cell&#39;: &#39;max&#39;,
                              &#39;Elevation_End&#39;: &#39;min&#39;,
                              &#39;Resistivity&#39;: [&#39;min&#39;, &#39;max&#39;, &#39;mean&#39;],
                              &#39;X&#39;: &#39;mean&#39;, &#39;Y&#39;: &#39;mean&#39;})
    agg_group.columns = agg_group.columns.map(&#39;_&#39;.join)
    agg_group.index.name = None
    agg_group[&#39;ID&#39;] = agg_group.index
    self.summary = agg_group
    self.summary.reset_index(drop=True, inplace=True)
    self.summary.rename(columns={&#39;X_mean&#39;: &#39;X&#39;, &#39;Y_mean&#39;: &#39;Y&#39;}, inplace=True)
    return self.summary</code></pre>
</details>
</dd>
<dt id="ttemtoolbox.core.process_ttem.ProcessTTEM.to_shp"><code class="name flex">
<span>def <span class="ident">to_shp</span></span>(<span>self, output_filepath: str | pathlib.PurePath)</span>
</code></dt>
<dd>
<div class="desc"><p>This method converts the tTEM data to a shapefile or other supported geospatial formats.</p>
<p>:param output_filepath: The path to save the output shapefile or geospatial file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_shp(self, output_filepath: str | pathlib.PurePath):
    &#34;&#34;&#34;
    This method converts the tTEM data to a shapefile or other supported geospatial formats.\n
    :param output_filepath: The path to save the output shapefile or geospatial file.
    
    &#34;&#34;&#34;
    ttem_gdf = gpd.GeoDataFrame(self.summary, 
                                geometry=gpd.points_from_xy(self.summary[&#39;X&#39;], self.summary[&#39;Y&#39;]),
                                crs=self.crs)
    if  Path(output_filepath).suffix.lower() == &#39;.shp&#39;:
        ttem_gdf.to_file(output_filepath, driver=&#39;ESRI Shapefile&#39;)
        print(&#39;The output file is saved to {}&#39;.format(Path(output_filepath).resolve()))
    elif Path(output_filepath).suffix.lower() == &#39;.gpkg&#39;:
        ttem_gdf.to_file(output_filepath, driver=&#39;GPKG&#39;, layer=Path(self.fname[0]).stem)
        print(&#39;The output file is saved to {}&#39;.format(Path(output_filepath).resolve()))
    elif Path(output_filepath).suffix.lower() == &#39;.geojson&#39;:
        ttem_gdf.to_file(output_filepath, driver=&#39;GeoJSON&#39;)
        print(&#39;The output file is saved to {}&#39;.format(Path(output_filepath).resolve()))
    else: 
        raise ValueError(&#34;The output file format is not supported, please use .shp, .gpkg, or .geojson&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ttemtoolbox.core" href="index.html">ttemtoolbox.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ttemtoolbox.core.process_ttem.ProcessTTEM" href="#ttemtoolbox.core.process_ttem.ProcessTTEM">ProcessTTEM</a></code></h4>
<ul class="">
<li><code><a title="ttemtoolbox.core.process_ttem.ProcessTTEM.reproject" href="#ttemtoolbox.core.process_ttem.ProcessTTEM.reproject">reproject</a></code></li>
<li><code><a title="ttemtoolbox.core.process_ttem.ProcessTTEM.set_crs" href="#ttemtoolbox.core.process_ttem.ProcessTTEM.set_crs">set_crs</a></code></li>
<li><code><a title="ttemtoolbox.core.process_ttem.ProcessTTEM.summary" href="#ttemtoolbox.core.process_ttem.ProcessTTEM.summary">summary</a></code></li>
<li><code><a title="ttemtoolbox.core.process_ttem.ProcessTTEM.to_shp" href="#ttemtoolbox.core.process_ttem.ProcessTTEM.to_shp">to_shp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>